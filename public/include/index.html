<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='UTF-8'>
    <meta content='width=device-width, initial-scale=1.0' name='viewport'>
    <title>; ) Interrupt Software</title>
    <link href='/include/vendor/bootstrap/css/bootstrap.min.css' rel='stylesheet'>
    <link href='/include/vendor/bootstrap/css/bootstrap-responsive.min.css' rel='stylesheet'>
    <link href='/include/vendor/Metro-UI-CSS/css/modern.css' rel='stylesheet'>
    <link href='/include/css/index.css' rel='stylesheet'>
    <script src='/include/vendor/jquery-2.0.0.min.js' type='text/javascript'></script>
    <script src='/include/vendor/bootstrap/js/bootstrap.min.js' type='text/javascript'></script>
    <script src='/include/vendor/jquery.serialScroll.js' type='text/javascript'></script>
    <script src='/include/vendor/jquery.scrollTo.js' type='text/javascript'></script>
    <script src='/include/vendor/jquery.easing.min.js' type='text/javascript'></script>
    <script src='/include/vendor/jquery.color-2.1.2.min.js' type='text/javascript'></script>
  </head>
  <body>
    <!-- .header -->
    <!-- .header-content -->
    <!-- .header-content-entry.secondary-title#bkeeping-entry -->
    <!-- bkeeping -->
    <!-- .header-content-entry.secondary-title#cloudeditor-entry -->
    <!-- cloudeditor -->
    <div class='slider'>
      <div class='slide-stretchable'>
        <div class='slide-wrapper' id='wrapper-home'>
          <div class='slide-container' id='slide-home'>
            <div class='slide-left-overhang'>
              ; )
            </div>
            <div class='slide-container-content'>
              <h1 class='primary-title'>
                Interrupt Software
              </h1>
              <h3 class='secondary-title'>
                Custom Software Development &#x2F; Advanced Functionality &amp; Design Excellence
              </h3>
              <h4 class='slide-content'>
                <p>
                  Tim is a gifted developer - thoughtful, strategic, and careful. We hired him to develop the StoryDesk CloudEditor. He delivered a beautiful, one-of-a-kind HTML5 content management system for iPad. I offer Tim my highest recommendation, as a colleague and a friend.
                </p>
                <div class='colleague'>
                  Jordan Stolper, CEO, StoryDesk.com
                </div>
                <p>
                  Tim is a strong Ruby and Rails developer, whom I worked with as a SCRUM Master on an operational data transformation and data store project. Tim was both proactive and balanced in his solutions from a business and technical standpoint, articulate, and was very effective in pair programming scenarios with different developers on the team. His attention to detail, adaptability and willingness to take on new challenges is further enhanced with his positive attitude. I would welcome working with Tim again and recommend him as a strong asset to any organization.
                </p>
                <div class='colleague'>
                  Cort Fowler, Product Manager and Business Analyst, Rogers Digital Media
                </div>
                <p>
                  Tim is one of the most intelligent, forward-thinking developers I've ever worked with. He possesses a deep pool of knowledge about all things related to software and uses that to engineer top-notch solutions. The diversity he's gained from experience with so many different languages and technologies gives him great perspective on technical approaches and strategies. He is also one of the most enthusiastic and proactive colleagues I've ever had the chance to work with, and I'm sure that he's up to any challenge that comes his way.
                </p>
                <div class='colleague'>
                  Stephen Kawaguchi, Engineer , Bank Of Montreal, IFL
                </div>
              </h4>
            </div>
          </div>
        </div>
        <div class='slide-wrapper' id='wrapper-blog'>
          <div class='slide-container' id='slide-blog'>
            <div class='slide-container-content'>
              <h1 class='primary-title'>
                Blog
              </h1>
              <h2 class='secondary-title'>
                A Developer's Toolbox (Rich Internet Applications)
              </h2>
              <h3 class='secondary-title'>
                Overview
              </h3>
              <h5 class='slide-content'>
                <p>
                  I'm often asked what are the best tools and technology stack for building a Web Application. For the purposes of this article, I'll focus on more advanced front-end representations - what are known as Rich Internet Applications (RIA(s)). I think it's useful to step back and consider the purpose and conceptions of Rich Internet Applications (RIA, synonymous with Single-Page Applications (SPA)). We can start by thinking back to when most applications were on the desktop. As the internet grew in popularity, Javascript was introduced into browsers (and Flash). Web pages grew in sophistication, as to begin to resemble full desktop apps. Now, we have things like Google docs, which are basically our old desktop apps extruded onto the web. I mention all of this in order to get us thinking about how we should be treating these new web apps. Ie, we should be treating these web apps like full applications. And with that, my opinion is that, to the highest degree possible, we should let a webapps do its own rendering, state changes, business logic, etc. It's a much cleaner design to i) pass raw HTML template chunks and ii) JSON data from RESTful services. The web app will have enough intelligence to take these, and generate a web view, UI functions, state transitions between the UI, etc. I advocate these principles to enforce a clean separation of concerns. It future-proofs the app, and allows for easily scaling machine resources, or adding new functionality. 
                </p>
                <p>
                  With this in mind, as an example, let's consider three MVC Web Frameworks - <a href="http://emberjs.com/">Ember</a>, <a href="http://angularjs.org/">Angular</a>, and <a href="http://backbonejs.org/">Backbone</a>. We'll take a semantic comparison between these libraries, and more, why a certain library would benefit us from a production, cost, time, future planning standpoint. So you can properly judge my position, I'll state from the beginning, my opinion that Backbone is usually the best tool for a front-end MVC solution. My experience is that it optimizes i) developer time (ie. speed to market), ii) production efficiency (it's very lightweight), iii) scalability, and iv) future flexibility. To begin, I present a useful <a href="http://blog.susestudio.com/2013/03/client-side-js-mv-framework-roundup.html">Client-side JS MV* Framework Roundup</a>. It gives a nod to the <a href="http://todomvc.com/">TodoMVC</a> project. TodoMVC implements a simple todo app in all the web MVC frameworks. It's meant to help you select the best one for your needs. 
                </p>
                <p>
                  Like Rails, Ember is meant to be an opinionated framework, using common idioms. Views are handled via 2-way binding against rendered moustache templates. Angular is meant to be a way of declaring dynamic views in web-applications. It does this by letting you extend HTML vocabulary for your application. Angular also defines its own set of attributes and markup, which are processed by its JS library to provide browser-specific behaviour. Backbone is intended to be a lightweight and focused way of building single-page applications (or RIAs). It gives structure to web applications by providing models with key-value binding and custom events, collections, views with declarative event handling, etc. It connects it all to an existing API over a RESTful JSON interface. 
                </p>
                <p>
                  With the above, I'll begin with my preference to eschew the moustache approach to templates, used by Ember. It tangles together the raw HTML template chunks, with transformation logic. And it unnecessarily forces web designers to know Javascript or some other logical transformation language, reducing developer efficiency. There are better, more declarative path-based solutions, like PureJS. Ember also implements rendering logic on the server. This tangles together application functions, reducing future flexibility and scalability. The tangling I described earlier is also why I eschew Angular. 
                </p>
                <p>
                  Now, broadly listing a technology stack, will not address enough cases. Below, I'll outline three scenarios, or types of web applications, and an appropriate technology stack baseline. With each set of choices, I'll explain the tool and the rationale behind that choice. But I also want to step back again, and take a more holistic approach to my solutions. Before the Scenario Breakdown, I'll describe my approaches to i) Project Management, ii) thoughts on Pair Programming, and iii) a good approach for Testing and Test Automation.
                </p>
              </h5>
              <h3 class='secondary-title'>
                Project Management
              </h3>
              <h5 class='slide-content'>
                <p>I think most software projects are good candidates for an Agile software development approach. Consider eXtreme Programming (XP) and Scrum, both Agile Methodologies. They are closely aligned, yet with subtle differences. XP uses strict priority order, and prescribes engineering practices (see here). I think it's appropriate to start with Scrum, then introduce elements of XP where needed (ie, Continuous Integration, TDD, etc). </p>
                <ul>
                  <li>With regard to roles within a project, at the very least, most will need the i) Product Owner ii) Team iii) Scrum Master and iv) the Project Manager. </li>
                  <li>Sprints of 2 weeks are a good starting point. This would include a Planning Meeting, where the i) tasks / Stories for the sprint are identified ii) Estimated and iii) Prioritized. Teams should also conclude each sprint with a review or Retrospective Meeting. This is where the progress is reviewed and lessons for the next sprint identified. And of course the software will be Delivered to and reviewed by the customer. </li>
                  <li>I find Daily Scrums to be overkill for most projects, unless teams can strictly keep them to 5 minutes. However, it's good practice to do constant Backlog Refinement. That being the process of creating stories, decomposing stories into smaller ones, refining, prioritizing and sizing existing stories using effort / points. </li>
                  <li>That leads to the next feature, adding a Points System to tasks. An abstract point system is used to discuss the difficulty of the story, without assigning actual hours.</li>
                  <li>Product Backlog is an ordered list of "requirements" that is maintained for a product. It consists of features, bug fixes, non-functional requirements, etc. - whatever needs to be done in order to successfully deliver a working software system. </li>
                  <li>Sprint Backlog is a subcomponent of the Product Backlog. It is the list of work the Development Team must address during the next sprint. The velocity previous sprints will guide the team when selecting stories/features for the new sprint. </li>
                  <li>Increment is the sum of all the Product Backlog Items completed during a sprint and all previous sprints. </li>
                  <li>Burn Down Chart is a publicly displayed chart showing remaining work in the sprint backlog. Updated routinely, it gives a simple view of the sprint progress.</li>
                </ul>
                <ul>
                  <li>Spike - A time boxed period used to research a concept and/or create a simple prototype. </li>
                  <li>Velocity - The total effort a team is capable of in a sprint. The number is derived by evaluating the story points completed from the last few sprint's stories/features. </li>
                  <li>Tracking - Both these tools have excellent project management features: Pivotal Tracker and FogBugz.</li>
                </ul>
                <p>A few other key project artifacts are itemized below. These are needed to maintain efficient management of developer hours: </p>
              </h5>
              <h3 class='secondary-title'>
                Thoughts On Pair Programming
              </h3>
              <h5 class='slide-content'>
                <p>I believe software team cohesion, is closely tied to how productive and empowered all team members feel. So we discussed starting with a solid development methodology. This usually means an Agile software development approach. A next good step is pair programming. I like the rock-solid code that is usually produced with pair-programming. I find some of the effects of pairing, are i) each programmer is more thoughtful wrt how they are designing the system(s); and ii) both programmers usually a wider breadth of technical knowledge and experience between them. This is because the person coding is usually required to verbally explain and justify their technical decisions. iii) And fewer tangents are made, due to the constant support of an ever-present partner. Also, pairs can and should switch between coding and supporting. This allows rest for each team member, and usually means the active coder is more fully alert.</p>
                <p>Full-time pair-programming is a good idea, if your team can afford it. However, it's sometimes necessary for a programmer to either i) quickly try out a solution or technology, to better understand the problem domain. Or ii) it's often necessary for someone to simply take time to think clearly about a problem (could involved reading books, blogs, etc). So in a full pairing engagement, time apart from coding could reasonably be managed by the pairs. </p>
              </h5>
              <h3 class='secondary-title'>
                Testing and Test Automation Solutions
              </h3>
              <h5 class='slide-content'>
                <p>Of course the testing framework would depend on the language in which we choose to implement the system. There are several levels and approaches to testing that are appropriate in each scenario. </p>
                <ul>
                  <li>Unit Tests (vs BDD) - Unit Tests addresses individual units of code. Alternatively, BDD, an outgrowth of TDD, focuses on the behavioural specification of software units</li>
                  <li>Acceptance tests (vs Generative testing) - Acceptance tests address the end-to-end functioning of the system. This is in contrast to Integration tests, which only test several layers of the system (but not everything). Generative testing is a newer idea. It is one where the code itself generates test cases. We typically write code to generate test cases according to one or more assumptions you would like to test. This is a good approach for more complex systems; when we want to test unanticipated inputs, over a wide range. </li>
                  <li>Simulation testing - Simulation testing, derived from disciplines such as engineering, disaster recovery, etc., is meant to be a rigorous, scalable, and reproducible approach to testing. Artifacts from each step (modelling, defining activity streams, execution, result capture, and validation) are captured in a time-aware database, so steps can be run (and re-run, and enhanced) independently of each other. </li>
                  <li>Continuous Integration (or Automated build) - Continuous integration (CI) merges all developer working copies with a shared mainline several times a day. Its main aim is to prevent integration problems, upon delivery of the software. </li>
                </ul>
                <p>So for example, consider a Ruby Rails versus a Clojure Compojure application. Generally, the pattern would be:</p>
                <ul>
                  <li>Ruby - RSpec (BDD) > Cucumber (Acceptance tests) > CruiseControl (Continuous Integration). This is a well-understood and battle-tested collection of test tools. It gives great test coverage for the simple version of our webapp. Generative or Simulation testing is not warranted in a simpler web application scenario. </li>
                  <li>Clojure - Speclj (BDD) > Test.generative (Generative tests) > Pallet (Continuous Integration). Speclj is a clean and straightforward approach to testing, while focusing on the behaviour of software units. Test.generative allows us to test the more general assumptions we have about the system. We then let the test tool generate potentially thousands of tests that validate our assumptions. This would be more appropriate than Acceptance tests, for a dynamic and streaming types of applications. And Pallet is a dev ops automation platform, with excellent integration with hudson/jenkins, and Clojure build tools. Simulation testing is probably not warranted if the application is more speculative in nature. Ie, users will often create and deploy new algorithms, quickly negating prescribed simulations. </li>
                </ul>
              </h5>
              <h3 class='secondary-title'>
                Scenario Breakdown
              </h3>
              <h5 class='slide-content'>
                <p>Before selecting a toolset, it's very important to know a few things about the system</p>
                <ul>
                  <li>What are the core function(s) ? </li>
                  <li>What is the expected time-to-delivery ?</li>
                  <li>Where the delivered application will live (incl. network reliability), and what DBs and with which services it must communicate ?</li>
                  <li>What are its users, and how much load the application is expected to see ?</li>
                  <li>Who will be maintaining the application upon delivery, and what are their skill-sets ?</li>
                </ul>
              </h5>
              <h3 class='secondary-title'>
                Scenario A)
              </h3>
              <h5 class='slide-content'>
                <p>This is a Rich Internet Application (akin to Pixelthrone), solely as a web tool, communicating with 3rd party cloud services. It will be a responsive front-end that is capable on smart phones, tablets, and varied screen sizes.</p>
                <ul>HAML / SCSS / Coffeescript / PureJS - Haml, Scss and Coffeescript compile down to html, css and javascript, respectively. They're higher level syntaxes that let developers write equivalent output code, in a much shorter amount of time. The added benefits greatly outweigh the added abstraction. PureJS is a lightweight templating tool, that eschews the moustache templating approach. My opinion is that the moustache approach, incorrectly tangles together document structure and logic in the same place. PureJS, instead uses path-like expressions for data locations.</ul>
                <ul>Backbone - Backbone has a focused and elegant approach to rendering choices. It also has a clean and lightweight approach to managing the internal state of the application (model and controller). And the RESTful server communication is also very consistent and well thought out. In short, these design advantages are what help optimize development and production costs, time, and future planning.</ul>
                <ul>Bootstrap - Bootstrap is an excellent front end framework with which many developers already have a strong knowledge level. However, there are advantages and disadvantages of this option, and some alternatives. </ul>
                <p>Advantages</p>
                <ul>
                  <li>Every HTML element that could potentially be used is accounted for. Meaning even rare tags, like <dl> , will be elegantly styled and positioned.</li>
                  <li>It lays a foundation for consistency that would take a good amount of time to achieve manually. Further, when a developer passes off the deliverable to the client, others will be able to 'extend' the original work without disturbing the general aesthetic.</li>
                  <li>It's facility for rapid prototyping, and again, most team's familiarity, means it would be quick to use and efficient.</li>
                </ul>
                <p>Disadvantages</p>
                <ul>
                  <li>Suboptimal for creating a performance driven web app</li>
                  <li>The framework can become too heavy, because so many things (html elements, etc) are included. It can be tough to quickly find what you're looking for. Additionally, troubleshooting unexpected margins and borders and whatnot can be difficult. </li>
                  <li>It's not bespoke, or tending toward a higher quality brand. It is a generic solution that a lot of startups use.</li>
                  <li>Customizing such a pervasive framework can be very tricky. Changing one thing might mean unintended effects on other elements.</li>
                </ul>
                <p>Alternatives </p>
                <ul>
                  <li>Foundation is a responsive front-end framework. It let's developers quickly prototype and build sites or apps that work on any kind of device. </li>
                  <li>HTML5 Boilerplate is a professional front-end template for building adaptable web apps or sites. It does not impose a specific development framework, freeing the developer to manipulate the code to their needs.</li>
                </ul>
              </h5>
              <h3 class='secondary-title'>
                Scenario B)
              </h3>
              <h5 class='slide-content'>
                <p>
                  A basic, SQL-backed webapp; simple set of functions, moderate usage, and Junior Sys Admins maintaining. 
                </p>
                <ul>
                  <li>HAML / SCSS / Coffeescript / PureJS - Haml, Scss and Coffeescript compile down to html, css and javascript, respectively. They're higher level syntaxes that let developers write equivalent output code, in a much shorter amount of time. The added benefits greatly outweigh the added abstraction. PureJS is a lightweight templating tool, that eschews the moustache templating approach (see here). I'll reiterate my opinion that the moustache approach, incorrectly tangles together document structure and logic in the same place. PureJS, instead uses path-like expressions for data locations.</li>
                  <li>Ruby / Rails / JSON data exchange - Ruby is an excellent dynamic, object-oriented language. It has language features (first-class-functions, simple syntax design, etc) that let programmers quickly build out capable, general-purpose solutions. Sinatra is good for simple webapps. However Rails gives i) better support for REST endpoints ii) more compatible libraries and iii) easier setup and migration of SQL database schemas and data. There's a good set of Rails / Sinatra tradeoffs here. And JSON is a well-known and supported data exchange format, especially for RESTful, AJAX calls </li>
                  <ul>
                    <li>not Sinatra - see Rails / Sinatra tradeoffs here</li>
                  </ul>
                  <li>PostgreSQL - The app data is rectangular and related. That makes SQL technology a good fit. schema and queries will be well-known before hand, meaning they won't require a lot of mutation after delivery. Postgres is a reliable, stable, and well-known RDBMS. It is open source, and has a license that's suitable for commercial purposes (see here).</li>
                </ul>
              </h5>
              <h3 class='secondary-title'>
                Scenario C)
              </h3>
              <h5 class='slide-content'>
                <p>
                  A complex, stateful UI, backed by several "big data" stores. Client wants to capture and analyse a constant stream of financial data. Researchers will take this data and need to create and deploy new algorithms and analytics on top of the data. This means real-time analytics, on a constant stream of data; high usage by very senior quantitative analysts and data scientists; maintained by Senior IT Personnel. 
                </p>
                <ul>
                  <li>HAML / SCSS - Haml and Scss compile down to html and css, respectively. They're higher level syntaxes that let developers write equivalent output code, in a much shorter amount of time. The added benefits greatly outweigh the added abstraction. </li>
                  <li>Coffeescript / PureJS / RequireJS / BackboneJS - Coffeescript compiles down to Javascript. It provides greater expressive power over javascript, using less code. The added benefits greatly outweigh the added abstraction. PureJS is a lightweight templating tool, that eschews the moustache templating approach (see here). I'll reiterate my opinion that the moustache approach, incorrectly tangles together document structure and logic in the same place. PureJS, instead uses path-like expressions for data locations. RequireJS is a very good tool for building component systems necessary in a large, complex thick-client. BackboneJS is a lightweight, well-thought out MVC tool for managing in-browser app state. </li>
                  <ul>
                    <li>
                      Thing
                    </li>
                  </ul>
                  <ul>
                    <li>almost Clojurescript, Enfocus, Functional Reactive Programming - These technologies would be a much better fit than the abouve, for the kind of real-time sensitive interactions in the app. Clojurescript especially, is ideal for computationally intensive, interactive applications (see here). However maintenance ability and cost is high. I would recommend this over RequireJS and BackboneJS if you have very good IT specialists as maintainers. Enfocus is a templating tool for Clojurescript. Like PureJS, it uses path-like expressions for data locations. Functional Reactive Programming (FRP) is an approach that uses Functional programming techniques to operate on data structures over time. Ideally, we'll want an FRP library that lets us more cleanly transform, compose, and query streams of data (mouse moves, stock streams, etc). </li>
                    <li>◦ not Websockets - There's more standard HTTP Server Sent Events (EventSource API) </li>
                  </ul>
                  <li>Clojure / Pedestal (for SSE support)  / Storm / JSON data exchange - Clojure provides a number of language features (first-class functions, homoiconic, immutable data, etc) that make it ideal for building complex, data intensive apps. Pedestal is a tool set for building web applications in Clojure. For this app, it has a number of useful features, such as built in SSE support. Storm is a distributed realtime computation system. It provides a set of utilities for doing realtime computation. I chose it over Hadoop, as Storm is used for real time processing while Hadoop is used for batch processing. JSON is a well-known and supported data exchange format, especially for RESTful, AJAX calls. </li>
                  <ul>
                    <li>almost EDN - would be a better data exchange format than JSON. This data format is extensible, has rich objects, and is serializable. But it's new, not in wide enough use, and not enough people understand it. I would only recommend this format if the client has very Senior maintainers. </li>
                  </ul>
                  <li>Datomic - I think Datomic is ideal as it i) decouples DB functions such as read & write (see here). It also ii) has a flexible schema model, allowing for changes to data structures, as users learn more about the domain. It also iii) has a sound data model based on time and immutability (more faithfully representing data over time) and iv) a logic-based query language (focus on facts). The downside is the specialized knowledge needed to maintain and query the database. But the advantages, and simplicity of the query language, mitigate those tradeoffs. All these other databases are close considerations. But they don't fit the bill due to their specialized nature. Whereas Datomic covers more ground, in terms of leveraging the data. You can see some DB tradeoffs here. </li>
                  <ul>
                    <li>not Cassandra - Our app will write to DB, more than it reads. And this is Cassandra's main advantage. Most reads will come from big data stream services (via Storm). </li>
                    <li>not Redis - Good for rapidly changing data sets (but not that much will be needed); but it works best when those data sets all must fit into memory  </li>
                    <li>not Neo4j - This is good for graph-style, rich or complex, interconnected data.</li>
                    <li>not Couchbase - Good for low-latency and high availability </li>
                    <li>not VoltDB - Good for reacting fast on large amounts of data </li>
                  </ul>
                </ul>
              </h5>
              <h3 class='secondary-title'>
                Further
              </h3>
              <h5 class='slide-content'>
                <p>
                  These technologies are simply a good baseline when considering building out a Rich Internet Application. There are other options, as with the rising popularity of Javascript on all devices. There's <a href="http://nodejs.org/">NodeJS</a> on the server, <a href="http://phonegap.com/">PhoneGap</a> native apps on the mobile device. Tools like <a href="https://github.com/rogerwang/node-webkit">Node-Webkit</a> also allow you to create desktop applications with Javascript. And with <a href="http://tessel.io/">Tessel</a>, we can even use it on our micro-controllers (ie <a href="http://www.arduino.cc/">Arduino</a>).
                </p>
                <p>
                  Beyond tools simply, teams should consider the kinds of language features and architectures appropriate for their needs. Features such as immutable data structures or first class functions (ie closures) offer a lot of benefits and usually be added in as a library or 3rd-party solution. Beyond that, even, techniques like Combinators and Functional Reactive Programming offer better control, albeit with increased abstraction. You can think creatively. I, personally, prefer tools that offer the greatest amount of expressive power. And at the same time optimize my i) developer time (ie. speed to market), ii) production efficiency (it's very lightweight), iii) scalability, and iv) future flexibility.
                </p>
              </h5>
            </div>
          </div>
        </div>
        <div class='slide-wrapper' id='wrapper-introduction'>
          <div class='slide-container' id='slide-introduction'>
            <div class='slide-container-content'>
              <h1 class='primary-title'>
                Introduction
              </h1>
              <h4 class='slide-content'>
                <p>
                  Interrupt Software is a premier software development boutique. I create and utilise the best tools possible, to identify the problem, craft a solution and distill the technology&apos;s role and interaction.
                </p>
                <p>
                  Interrupt Software offers advanced functionality and design excellence. Technology is more than the context. It has the ability to reimagine behaviour and experience. It connects users with messages and customers with business. And this creates a tremendous amount of business value.
                </p>
                <p>
                  At Interrupt Software, I program as fast as I think. There's a great deal a of value in a well thought out solution. And doing it well leverages your investment for long-term impact.
                </p>
              </h4>
            </div>
          </div>
        </div>
        <div class='slide-wrapper' id='wrapper-approach'>
          <div class='slide-container' id='slide-approach'>
            <div class='slide-container-content'>
              <h1 class='primary-title'>
                Approach
              </h1>
              <h4 class='slide-content'>
                <p>
                  As a Full Stack developer, I see solutions at all levels. Considerations range from user needs to innovation and software craftsmanship.
                </p>
                <p>
                  My skill applies not only to custom building your software. It also creates better solutions, faster, by extracting greater expressive power from my software tools.
                </p>
              </h4>
              <h3 class='secondary-title'>
                Understanding The Problem.
              </h3>
              <h4 class='slide-content'>
                <p>
                  To break new ground, you have to understand the context. Each business and customer is different. I assess and evaluate all elements so I can effectively conceptualize the most advanced problems.
                </p>
              </h4>
              <h3 class='secondary-title'>
                Choosing My Tools
              </h3>
              <h4 class='slide-content'>
                <p>
                  My expertise is in knowing what tools to utilise and to what extent. As much utilization as creation, I select best-of-breed tools that enable me to program as fast as I problem solve.
                </p>
              </h4>
              <h3 class='secondary-title'>
                Crafting Impactful Solutions
              </h3>
              <h4 class='slide-content'>
                <p>
                  I aim to generate business and technological value with the solutions I deliver to you. They have to perform on every level, be as visually stunning as functionally impactful.
                </p>
              </h4>
            </div>
          </div>
        </div>
        <div class='slide-wrapper' id='wrapper-services'>
          <div class='slide-container' id='slide-services'>
            <div class='slide-container-content'>
              <h1 class='primary-title'>
                Services
              </h1>
              <h4 class='slide-content'>
                I can consult on your project in 3 key areas
              </h4>
              <h3 class='secondary-title'>
                System Analysis
              </h3>
              <h4 class='slide-content'>
                Helping you define the scope and purpose of your system.
              </h4>
              <h3 class='secondary-title'>
                System Design
              </h3>
              <h4 class='slide-content'>
                Shaping the experience.
              </h4>
              <h3 class='secondary-title'>
                System Implementation
              </h3>
              <h4 class='slide-content'>
                Using best-of-breed tools to customize a solution for your needs.
              </h4>
            </div>
          </div>
        </div>
        <div class='slide-wrapper' id='wrapper-about'>
          <div class='slide-container' id='slide-about'>
            <div class='slide-left-overhang' id='me-pic'></div>
            <div class='slide-container-content'>
              <h1 class='primary-title'>
                About
              </h1>
              <h4 class='slide-content'>
                <p>
                  Interrupt Software is Timothy Washington
                </p>
                <p>
                  Highly experienced and respected in the digital realm, he is a keen advocate of technology as a world view. He is a senior software developer with over a decade of experience architecting and building custom and enterprise software solutions. Tim is also an avid contributor to the open source community. he is an expert utiliser and visionary. From Lehman Brothers to Conde Nast, his vast portfolio reflects his eclectic expertise, professionalism and passion for his craft and its industry impact.
                </p>
              </h4>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class='navigation'>
      <div class='container'>
        <div id='right-nav'>
          <div class='nav-item circle' id='home'>
            <span></span>
          </div>
          <div class='nav-item-label'>
            home
          </div>
          <div class='nav-item circle' id='blog'></div>
          <div class='nav-item-label'>
            blog
          </div>
          <div class='nav-item circle' id='introduction'></div>
          <div class='nav-item-label'>
            introduction
          </div>
          <div class='nav-item circle' id='approach'></div>
          <div class='nav-item-label'>
            approach
          </div>
          <div class='nav-item circle' id='services'></div>
          <div class='nav-item-label'>
            services
          </div>
          <div class='nav-item circle' id='about'></div>
          <div class='nav-item-label'>
            about
          </div>
          <div class='nav-item circle spacer'></div>
          <div class='nav-item-label spacer'>
            &nbsp;
          </div>
          <!-- / CV -->
          <div class='nav-item squeeze' id='cv'>
            <div class='metrouicss'>
              <div class='icons'>
                <li>
                  <div class='icon-lines'></div>
                </li>
              </div>
            </div>
          </div>
          <div class='nav-item-label squeeze'>
            cv
          </div>
          <!-- / Email -->
          <div class='nav-item squeeze' id='email'>
            <div class='metrouicss'>
              <div class='icons'>
                <li>
                  <div class='icon-mail'></div>
                </li>
              </div>
            </div>
          </div>
          <div class='nav-item-label squeeze'>
            email
          </div>
          <!-- / Twitter -->
          <div class='nav-item squeeze' id='twitter'>
            <div class='metrouicss'>
              <div class='icons'>
                <li>
                  <div class='icon-twitter'></div>
                </li>
              </div>
            </div>
          </div>
          <div class='nav-item-label squeeze'>
            twitter
          </div>
          <!-- / LinkedIn -->
          <div class='nav-item squeeze' id='linkedin'>
            <div class='metrouicss'>
              <div class='icons'>
                <li>
                  <div class='icon-linkedin'></div>
                </li>
              </div>
            </div>
          </div>
          <div class='nav-item-label squeeze'>
            linkedIn
          </div>
          <!-- / Github -->
          <div class='nav-item squeeze' id='github'>
            <div class='metrouicss'>
              <div class='icons'>
                <li>
                  <div class='icon-github-2'></div>
                </li>
              </div>
            </div>
          </div>
          <div class='nav-item-label squeeze'>
            github
          </div>
        </div>
      </div>
    </div>
    <!-- .footer -->
    <script src='/include/js/index.js' type='text/javascript'></script>
  </body>
</html>
